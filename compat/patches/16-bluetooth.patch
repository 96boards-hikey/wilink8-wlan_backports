diff -Nur a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
--- a/drivers/bluetooth/hci_ldisc.c	2009-11-25 11:24:32.000000000 +0530
+++ b/drivers/bluetooth/hci_ldisc.c	2009-11-28 10:56:22.000000000 +0530
@@ -277,8 +277,13 @@
	/* FIXME: why is this needed. Note don't use ldisc_ref here as the
	   open path is before the ldisc is referencable */

+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30))
	if (tty->ldisc->ops->flush_buffer)
		tty->ldisc->ops->flush_buffer(tty);
+#else
+	if (tty->ldisc.ops->flush_buffer)
+		tty->ldisc.ops->flush_buffer(tty);
+#endif
	tty_driver_flush_buffer(tty);

	return 0;
@@ -478,7 +483,11 @@
		return -EUNATCH;

	default:
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
		err = n_tty_ioctl_helper(tty, file, cmd, arg);
+#else
+		err = n_tty_ioctl(tty, file, cmd, arg);
+#endif
		break;
	};

--- a/net/bluetooth/af_bluetooth.c	2009-12-10 09:20:31.000000000 -0800
+++ b/net/bluetooth/af_bluetooth.c	2009-12-10 09:20:33.000000000 -0800
@@ -338,7 +338,11 @@ int bt_sock_ioctl(struct socket *sock, u
 		if (sk->sk_state == BT_LISTEN)
 			return -EINVAL;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 		amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);
+#else
+    amount = sk->sk_sndbuf - atomic_read(&sk->sk_wmem_alloc);
+#endif
 		if (amount < 0)
 			amount = 0;
 		err = put_user(amount, (int __user *) arg);
diff -Nur a/net/bluetooth/cmtp/capi.c b/net/bluetooth/cmtp/capi.c
--- a/net/bluetooth/cmtp/capi.c	2009-11-25 11:24:43.000000000 +0530
+++ b/net/bluetooth/cmtp/capi.c	2009-11-26 16:43:42.000000000 +0530
@@ -382,7 +382,11 @@

	BT_DBG("ctrl %p", ctrl);

+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30))
	capi_ctr_down(ctrl);
+#else
+	capi_ctr_reseted(ctrl);
+#endif

	atomic_inc(&session->terminate);
	cmtp_schedule(session);
diff -Nur a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
--- a/net/bluetooth/hci_core.c	2009-11-25 11:24:43.000000000 +0530
+++ b/net/bluetooth/hci_core.c	2009-11-26 16:01:35.000000000 +0530
@@ -39,7 +39,12 @@
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
 #include <linux/notifier.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
+
 #include <net/sock.h>

 #include <asm/system.h>
--- a/net/bluetooth/hci_sock.c	2009-12-10 09:40:08.000000000 -0800
+++ b/net/bluetooth/hci_sock.c	2009-12-10 09:40:59.000000000 -0800
@@ -471,7 +471,11 @@
 	goto done;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static int hci_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int len)
+#else
+static int hci_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int len)
+#endif
 {
 	struct hci_ufilter uf = { .opcode = 0 };
 	struct sock *sk = sock->sk;
diff -Nur a/net/bluetooth/hci_sysfs.c b/net/bluetooth/hci_sysfs.c
--- a/net/bluetooth/hci_sysfs.c	2009-11-25 11:24:43.000000000 +0530
+++ b/net/bluetooth/hci_sysfs.c	2009-11-27 15:19:26.000000000 +0530
@@ -68,7 +68,11 @@
	.attrs = bt_link_attrs,
 };

+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static const struct attribute_group *bt_link_groups[] = {
+#else
+static struct attribute_group *bt_link_groups[] = {
+#endif
	&bt_link_group,
	NULL
 };
@@ -126,7 +130,11 @@
		dev = device_find_child(&conn->dev, NULL, __match_tty);
		if (!dev)
			break;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
		device_move(dev, NULL, DPM_ORDER_DEV_LAST);
+#else
+		device_move(dev, NULL);
+#endif
		put_device(dev);
	}

@@ -392,7 +400,11 @@
	.attrs = bt_host_attrs,
 };

+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static const struct attribute_group *bt_host_groups[] = {
+#else
+static struct attribute_group *bt_host_groups[] = {
+#endif
	&bt_host_group,
	NULL
 };
--- a/net/bluetooth/hidp/core.c	2009-12-10 09:43:25.000000000 -0800
+++ b/net/bluetooth/hidp/core.c	2009-12-10 09:45:09.000000000 -0800
@@ -583,10 +583,16 @@ static int hidp_session(void *arg)
 		session->input = NULL;
 	}
 
-	if (session->hid) {
-		hid_destroy_device(session->hid);
-		session->hid = NULL;
-	}
+  if (session->hid) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
+    hid_destroy_device(session->hid);
+    session->hid = NULL;
+#else
+    if (session->hid->claimed & HID_CLAIMED_INPUT)
+      hidinput_disconnect(session->hid);
+    hid_free_device(session->hid);
+#endif
+  }
 
 	/* Wakeup user-space polling for socket errors */
 	session->intr_sock->sk->sk_err = EUNATCH;
@@ -698,6 +704,7 @@ static void hidp_close(struct hid_device
 {
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 static int hidp_parse(struct hid_device *hid)
 {
 	struct hidp_session *session = hid->driver_data;
@@ -762,15 +769,44 @@ static struct hid_ll_driver hidp_hid_dri
 };
 
 static int hidp_setup_hid(struct hidp_session *session,
+#else
+static const struct {
+	__u16 idVendor;
+	__u16 idProduct;
+	unsigned quirks;
+} hidp_blacklist[] = {
+	/* Apple wireless Mighty Mouse */
+	{ 0x05ac, 0x030c, HID_QUIRK_MIGHTYMOUSE | HID_QUIRK_INVERT_HWHEEL },
+
+	{ }	/* Terminating entry */
+};
+static void hidp_setup_quirks(struct hid_device *hid)
+{
+	unsigned int n;
+
+	for (n = 0; hidp_blacklist[n].idVendor; n++)
+		if (hidp_blacklist[n].idVendor == le16_to_cpu(hid->vendor) &&
+				hidp_blacklist[n].idProduct == le16_to_cpu(hid->product))
+			hid->quirks = hidp_blacklist[n].quirks;
+}
+static void hidp_setup_hid(struct hidp_session *session,
+#endif
 				struct hidp_connadd_req *req)
 {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	struct hid_device *hid;
-	bdaddr_t src, dst;
 	int err;
+#else
+	struct hid_device *hid = session->hid;
+	struct hid_report *report;
+#endif
+	bdaddr_t src, dst;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	hid = hid_allocate_device();
 	if (IS_ERR(hid))
 		return PTR_ERR(session->hid);
+#endif
 
 	session->hid = hid;
 	session->req = req;
@@ -789,6 +825,8 @@ static int hidp_setup_hid(struct hidp_se
 	strncpy(hid->phys, batostr(&src), 64);
 	strncpy(hid->uniq, batostr(&dst), 64);
 
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	hid->dev.parent = hidp_get_device(session);
 	hid->ll_driver = &hidp_hid_driver;
 
@@ -805,6 +843,24 @@ failed:
 	session->hid = NULL;
 
 	return err;
+#else
+	hid->dev = hidp_get_device(session);
+	hid->hid_open  = hidp_open;
+	hid->hid_close = hidp_close;
+
+	hid->hidinput_input_event = hidp_hidinput_event;
+
+	hidp_setup_quirks(hid);
+
+	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].report_list, list)
+		hidp_send_report(session, report);
+
+	list_for_each_entry(report, &hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+		hidp_send_report(session, report);
+
+	if (hidinput_connect(hid) == 0)
+		hid->claimed |= HID_CLAIMED_INPUT;
+#endif
 }
 
 int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock, struct socket *intr_sock)
@@ -824,6 +880,39 @@ int hidp_add_connection(struct hidp_conn
 
 	BT_DBG("rd_data %p rd_size %d", req->rd_data, req->rd_size);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+	if (req->rd_size > 0) {
+		unsigned char *buf = kmalloc(req->rd_size, GFP_KERNEL);
+
+		if (!buf) {
+			kfree(session);
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(buf, req->rd_data, req->rd_size)) {
+			kfree(buf);
+			kfree(session);
+			return -EFAULT;
+		}
+
+		session->hid = hid_parse_report(buf, req->rd_size);
+
+		kfree(buf);
+
+		if (!session->hid) {
+			kfree(session);
+			return -EINVAL;
+		}
+	}
+
+	if (!session->hid) {
+		session->input = input_allocate_device();
+		if (!session->input) {
+			kfree(session);
+			return -ENOMEM;
+		}
+	}
+#endif
 	down_write(&hidp_session_sem);
 
 	s = __hidp_get_session(&bt_sk(ctrl_sock->sk)->dst);
@@ -851,6 +940,7 @@ int hidp_add_connection(struct hidp_conn
 	session->flags   = req->flags & (1 << HIDP_BLUETOOTH_VENDOR_ID);
 	session->idle_to = req->idle_to;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	if (req->rd_size > 0) {
 		err = hidp_setup_hid(session, req);
 		if (err && err != -ENODEV)
@@ -862,6 +952,16 @@ int hidp_add_connection(struct hidp_conn
 		if (err < 0)
 			goto purge;
 	}
+#else
+	if (session->input) {
+		err = hidp_setup_input(session, req);
+		if (err < 0)
+			goto failed;
+	}
+
+	if (session->hid)
+		hidp_setup_hid(session, req);
+#endif
 
 	__hidp_link_session(session);
 
@@ -893,6 +993,7 @@ unlink:
 		session->input = NULL;
 	}
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	if (session->hid) {
 		hid_destroy_device(session->hid);
 		session->hid = NULL;
@@ -901,10 +1002,15 @@ unlink:
 purge:
 	skb_queue_purge(&session->ctrl_transmit);
 	skb_queue_purge(&session->intr_transmit);
+#endif
 
 failed:
 	up_write(&hidp_session_sem);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27))
+	if (session->hid)
+		hid_free_device(session->hid);
+#endif
 	input_free_device(session->input);
 	kfree(session);
 	return err;
@@ -994,6 +1100,7 @@ int hidp_get_conninfo(struct hidp_connin
 	return err;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 static const struct hid_device_id hidp_table[] = {
 	{ HID_BLUETOOTH_DEVICE(HID_ANY_ID, HID_ANY_ID) },
 	{ }
@@ -1003,6 +1110,7 @@ static struct hid_driver hidp_driver = {
 	.name = "generic-bluetooth",
 	.id_table = hidp_table,
 };
+#endif
 
 static int __init hidp_init(void)
 {
@@ -1012,11 +1120,14 @@ static int __init hidp_init(void)
 
 	BT_INFO("HIDP (Human Interface Emulation) ver %s", VERSION);
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	ret = hid_register_driver(&hidp_driver);
 	if (ret)
 		goto err;
+#endif
 
 	ret = hidp_init_sockets();
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	if (ret)
 		goto err_drv;
 
@@ -1024,13 +1135,16 @@ static int __init hidp_init(void)
 err_drv:
 	hid_unregister_driver(&hidp_driver);
 err:
+#endif
 	return ret;
 }
 
 static void __exit hidp_exit(void)
 {
 	hidp_cleanup_sockets();
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 	hid_unregister_driver(&hidp_driver);
+#endif
 }
 
 module_init(hidp_init);
--- a/net/bluetooth/l2cap.c	2009-12-10 09:47:08.000000000 -0800
+++ b/net/bluetooth/l2cap.c	2009-12-10 09:47:10.000000000 -0800
@@ -1762,7 +1762,11 @@ static int l2cap_sock_setsockopt_old(str
 	return err;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
+#else
+static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+#endif
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
--- a/net/bluetooth/rfcomm/sock.c	2009-12-10 09:48:33.000000000 -0800
+++ b/net/bluetooth/rfcomm/sock.c	2009-12-10 09:48:37.000000000 -0800
@@ -767,7 +767,11 @@ static int rfcomm_sock_setsockopt_old(st
 	return err;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
+#else
+static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+#endif
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
diff -Nur a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
--- a/net/bluetooth/rfcomm/tty.c	2009-11-25 11:24:43.000000000 +0530
+++ b/net/bluetooth/rfcomm/tty.c	2009-11-27 15:25:36.000000000 +0530
@@ -731,8 +731,12 @@
	remove_wait_queue(&dev->wait, &wait);

	if (err == 0)
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
		device_move(dev->tty_dev, rfcomm_get_device(dev),
			    DPM_ORDER_DEV_AFTER_PARENT);
+#else
+		device_move(dev->tty_dev, rfcomm_get_device(dev));
+#endif

	rfcomm_tty_copy_pending(dev);

@@ -752,7 +756,11 @@

	if (atomic_dec_and_test(&dev->opened)) {
		if (dev->tty_dev->parent)
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29))
			device_move(dev->tty_dev, NULL, DPM_ORDER_DEV_LAST);
+#else
+			device_move(dev->tty_dev, NULL);
+#endif

		/* Close DLC and dettach TTY */
		rfcomm_dlc_close(dev->dlc, 0);
--- a/net/bluetooth/sco.c	2009-12-10 09:49:34.000000000 -0800
+++ b/net/bluetooth/sco.c	2009-12-10 09:49:36.000000000 -0800
@@ -645,7 +645,11 @@ static int sco_sock_sendmsg(struct kiocb
 	return err;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31))
 static int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
+#else
+static int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+#endif
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
