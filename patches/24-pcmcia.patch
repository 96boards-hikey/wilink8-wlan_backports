--- a/drivers/bluetooth/bluecard_cs.c
+++ b/drivers/bluetooth/bluecard_cs.c
@@ -865,6 +865,12 @@ static int bluecard_probe(struct pcmcia_
 	info->p_dev = link;
 	link->priv = info;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+
+	link->irq.Handler = bluecard_interrupt;
+#endif
+
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 
@@ -902,9 +908,15 @@ static int bluecard_config(struct pcmcia
 	if (i != 0)
 		goto failed;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	i = pcmcia_request_irq(link, bluecard_interrupt);
 	if (i != 0)
 		goto failed;
+#else
+	i = pcmcia_request_irq(link, &link->irq);
+	if (i != 0)
+		link->irq.AssignedIRQ = 0;
+#endif
 
 	i = pcmcia_request_configuration(link, &link->conf);
 	if (i != 0)
--- a/drivers/bluetooth/bt3c_cs.c
+++ b/drivers/bluetooth/bt3c_cs.c
@@ -660,6 +660,12 @@ static int bt3c_probe(struct pcmcia_devi
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 	link->resource[0]->end = 8;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+
+	link->irq.Handler = bt3c_interrupt;
+#endif
+
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 
@@ -738,9 +744,15 @@ static int bt3c_config(struct pcmcia_dev
 	goto failed;
 
 found_port:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	i = pcmcia_request_irq(link, &bt3c_interrupt);
 	if (i != 0)
 		goto failed;
+#else
+	i = pcmcia_request_irq(link, &link->irq);
+	if (i != 0)
+		link->irq.AssignedIRQ = 0;
+#endif
 
 	i = pcmcia_request_configuration(link, &link->conf);
 	if (i != 0)
--- a/drivers/bluetooth/btuart_cs.c
+++ b/drivers/bluetooth/btuart_cs.c
@@ -589,6 +589,12 @@ static int btuart_probe(struct pcmcia_de
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 	link->resource[0]->end = 8;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+
+	link->irq.Handler = btuart_interrupt;
+#endif
+
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 
@@ -667,9 +673,15 @@ static int btuart_config(struct pcmcia_d
 	goto failed;
 
 found_port:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	i = pcmcia_request_irq(link, btuart_interrupt);
 	if (i != 0)
 		goto failed;
+#else
+	i = pcmcia_request_irq(link, &link->irq);
+	if (i != 0)
+		link->irq.AssignedIRQ = 0;
+#endif
 
 	i = pcmcia_request_configuration(link, &link->conf);
 	if (i != 0)
--- a/drivers/bluetooth/dtl1_cs.c
+++ b/drivers/bluetooth/dtl1_cs.c
@@ -574,6 +574,10 @@ static int dtl1_probe(struct pcmcia_devi
 
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 	link->resource[0]->end = 8;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+	link->irq.Handler = dtl1_interrupt;
+#endif
 
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
@@ -616,9 +620,15 @@ static int dtl1_config(struct pcmcia_dev
 	if (pcmcia_loop_config(link, dtl1_confcheck, NULL) < 0)
 		goto failed;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	i = pcmcia_request_irq(link, dtl1_interrupt);
 	if (i != 0)
 		goto failed;
+#else
+	i = pcmcia_request_irq(link, &link->irq);
+	if (i != 0)
+		link->irq.AssignedIRQ = 0;
+#endif
 
 	i = pcmcia_request_configuration(link, &link->conf);
 	if (i != 0)
--- a/drivers/net/wireless/b43/pcmcia.c
+++ b/drivers/net/wireless/b43/pcmcia.c
@@ -89,7 +89,14 @@ static int __devinit b43_pcmcia_probe(st
 	if (res != 0)
 		goto err_disable;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	if (!dev->irq)
+#else
+	dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+	dev->irq.Handler = NULL; /* The handler is registered later. */
+	res = pcmcia_request_irq(dev, &dev->irq);
+	if (res != 0)
+#endif
 		goto err_disable;
 
 	res = pcmcia_request_configuration(dev, &dev->conf);
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -776,7 +776,11 @@ static void if_cs_release(struct pcmcia_
 
 	lbs_deb_enter(LBS_DEB_CS);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	free_irq(p_dev->irq, card);
+#else
+	free_irq(p_dev->irq.AssignedIRQ, card);
+#endif
 	pcmcia_disable_device(p_dev);
 	if (card->iobase)
 		ioport_unmap(card->iobase);
@@ -801,9 +805,15 @@ static int if_cs_ioprobe(struct pcmcia_d
 			 unsigned int vcc,
 			 void *priv_data)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
 	p_dev->resource[0]->start = cfg->io.win[0].base;
 	p_dev->resource[0]->end = cfg->io.win[0].len;
+#else
+	p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+	p_dev->io.BasePort1 = cfg->io.win[0].base;
+	p_dev->io.NumPorts1 = cfg->io.win[0].len;
+#endif
 
 	/* Do we need to allocate an interrupt? */
 	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
@@ -815,7 +825,11 @@ static int if_cs_ioprobe(struct pcmcia_d
 	}
 
 	/* This reserves IO space but doesn't actually enable it */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	return pcmcia_request_io(p_dev);
+#else
+	return pcmcia_request_io(p_dev, &p_dev->io);
+#endif
 }
 
 static int if_cs_probe(struct pcmcia_device *p_dev)
@@ -835,6 +849,11 @@ static int if_cs_probe(struct pcmcia_dev
 	card->p_dev = p_dev;
 	p_dev->priv = card;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+	p_dev->irq.Handler = NULL;
+#endif
+
 	p_dev->conf.Attributes = 0;
 	p_dev->conf.IntType = INT_MEMORY_AND_IO;
 
@@ -849,12 +868,26 @@ static int if_cs_probe(struct pcmcia_dev
 	 * a handler to the interrupt, unless the 'Handler' member of
 	 * the irq structure is initialized.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	if (!p_dev->irq)
 		goto out1;
+#else
+	if (p_dev->conf.Attributes & CONF_ENABLE_IRQ) {
+		ret = pcmcia_request_irq(p_dev, &p_dev->irq);
+		if (ret) {
+			lbs_pr_err("error in pcmcia_request_irq\n");
+			goto out1;
+		}
+	}
+#endif
 
 	/* Initialize io access */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	card->iobase = ioport_map(p_dev->resource[0]->start,
 				resource_size(p_dev->resource[0]));
+#else
+	card->iobase = ioport_map(p_dev->io.BasePort1, p_dev->io.NumPorts1);
+#endif
 	if (!card->iobase) {
 		lbs_pr_err("error in ioport_map\n");
 		ret = -EIO;
@@ -873,7 +906,17 @@ static int if_cs_probe(struct pcmcia_dev
 	}
 
 	/* Finally, report what we've done */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	lbs_deb_cs("irq %d, io %pR", p_dev->irq, p_dev->resource[0]);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	lbs_deb_cs("irq %d, io 0x%04x-0x%04x\n",
+		  p_dev->irq, p_dev->io.BasePort1,
+		  p_dev->io.BasePort1 + p_dev->io.NumPorts1 - 1);
+#else
+	lbs_deb_cs("irq %d, io 0x%04x-0x%04x\n",
+		  p_dev->irq.AssignedIRQ, p_dev->io.BasePort1,
+		  p_dev->io.BasePort1 + p_dev->io.NumPorts1 - 1);
+#endif
 
 	/*
 	 * Most of the libertas cards can do unaligned register access, but some
@@ -929,7 +972,11 @@ static int if_cs_probe(struct pcmcia_dev
 	priv->fw_ready = 1;
 
 	/* Now actually get the IRQ */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	ret = request_irq(p_dev->irq, if_cs_interrupt,
+#else
+	ret = request_irq(p_dev->irq.AssignedIRQ, if_cs_interrupt,
+#endif
 		IRQF_SHARED, DRV_NAME, card);
 	if (ret) {
 		lbs_pr_err("error in request_irq\n");
--- a/drivers/net/wireless/orinoco/orinoco_cs.c
+++ b/drivers/net/wireless/orinoco/orinoco_cs.c
@@ -79,7 +79,11 @@ orinoco_cs_hard_reset(struct orinoco_pri
 	/* We need atomic ops here, because we're not holding the lock */
 	set_bit(0, &card->hard_reset_in_progress);
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27)
+	err = pcmcia_reset_card(link, NULL);
+#else
 	err = pcmcia_reset_card(link->socket);
+#endif
 	if (err)
 		return err;
 
@@ -117,6 +121,12 @@ orinoco_cs_probe(struct pcmcia_device *l
 	card->p_dev = link;
 	link->priv = priv;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	/* Interrupt setup */
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+	link->irq.Handler = orinoco_interrupt;
+#endif
+
 	/* General socket configuration defaults can go here.  In this
 	 * client, we assume very little, and rely on the CIS for
 	 * almost everything.  In most clients, many details (i.e.,
@@ -191,23 +201,48 @@ static int orinoco_cs_config_check(struc
 	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
 
 	/* IO window settings */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 	p_dev->resource[0]->end = p_dev->resource[1]->end = 0;
+#else
+	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
+#endif
 	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
 		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 		p_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;
 		p_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
 		p_dev->resource[0]->flags |=
 			pcmcia_io_cfg_data_width(io->flags);
 		p_dev->resource[0]->start = io->win[0].base;
 		p_dev->resource[0]->end = io->win[0].len;
+#else
+		p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+		if (!(io->flags & CISTPL_IO_8BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+		if (!(io->flags & CISTPL_IO_16BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+		p_dev->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+		p_dev->io.BasePort1 = io->win[0].base;
+		p_dev->io.NumPorts1 = io->win[0].len;
+#endif
 		if (io->nwin > 1) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 			p_dev->resource[1]->flags = p_dev->resource[0]->flags;
 			p_dev->resource[1]->start = io->win[1].base;
 			p_dev->resource[1]->end = io->win[1].len;
+#else
+			p_dev->io.Attributes2 = p_dev->io.Attributes1;
+			p_dev->io.BasePort2 = io->win[1].base;
+			p_dev->io.NumPorts2 = io->win[1].len;
+#endif
 		}
 
 		/* This reserves IO space but doesn't actually enable it */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 		if (pcmcia_request_io(p_dev) != 0)
+#else
+		if (pcmcia_request_io(p_dev, &p_dev->io) != 0)
+#endif
 			goto next_entry;
 	}
 	return 0;
@@ -248,15 +283,23 @@ orinoco_cs_config(struct pcmcia_device *
 		goto failed;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	ret = pcmcia_request_irq(link, orinoco_interrupt);
+#else
+	ret = pcmcia_request_irq(link, &link->irq);
+#endif
 	if (ret)
 		goto failed;
 
 	/* We initialize the hermes structure before completing PCMCIA
 	 * configuration just in case the interrupt handler gets
 	 * called. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 	mem = ioport_map(link->resource[0]->start,
 			resource_size(link->resource[0]));
+#else
+	mem = ioport_map(link->io.BasePort1, link->io.NumPorts1);
+#endif
 	if (!mem)
 		goto failed;
 
@@ -278,8 +321,16 @@ orinoco_cs_config(struct pcmcia_device *
 	}
 
 	/* Register an interface with the stack */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	if (orinoco_if_add(priv, link->resource[0]->start,
 			   link->irq, NULL) != 0) {
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	if (orinoco_if_add(priv, link->io.BasePort1,
+			   link->irq, NULL) != 0) {
+#else
+	if (orinoco_if_add(priv, link->io.BasePort1,
+			   link->irq.AssignedIRQ, NULL) != 0) {
+#endif
 		printk(KERN_ERR PFX "orinoco_if_add() failed\n");
 		goto failed;
 	}
--- a/drivers/net/wireless/orinoco/spectrum_cs.c
+++ b/drivers/net/wireless/orinoco/spectrum_cs.c
@@ -179,6 +179,12 @@ spectrum_cs_probe(struct pcmcia_device *
 	card->p_dev = link;
 	link->priv = priv;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	/* Interrupt setup */
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+	link->irq.Handler = orinoco_interrupt;
+#endif
+
 	/* General socket configuration defaults can go here.  In this
 	 * client, we assume very little, and rely on the CIS for
 	 * almost everything.  In most clients, many details (i.e.,
@@ -253,23 +259,48 @@ static int spectrum_cs_config_check(stru
 	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
 
 	/* IO window settings */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 	p_dev->resource[0]->end = p_dev->resource[1]->end = 0;
+#else
+	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
+#endif
 	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
 		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 		p_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;
 		p_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
 		p_dev->resource[0]->flags |=
 			pcmcia_io_cfg_data_width(io->flags);
 		p_dev->resource[0]->start = io->win[0].base;
 		p_dev->resource[0]->end = io->win[0].len;
+#else
+		p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+		if (!(io->flags & CISTPL_IO_8BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+		if (!(io->flags & CISTPL_IO_16BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+		p_dev->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+		p_dev->io.BasePort1 = io->win[0].base;
+		p_dev->io.NumPorts1 = io->win[0].len;
+#endif
 		if (io->nwin > 1) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 			p_dev->resource[1]->flags = p_dev->resource[0]->flags;
 			p_dev->resource[1]->start = io->win[1].base;
 			p_dev->resource[1]->end = io->win[1].len;
+#else
+			p_dev->io.Attributes2 = p_dev->io.Attributes1;
+			p_dev->io.BasePort2 = io->win[1].base;
+			p_dev->io.NumPorts2 = io->win[1].len;
+#endif
 		}
 
 		/* This reserves IO space but doesn't actually enable it */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 		if (pcmcia_request_io(p_dev) != 0)
+#else
+		if (pcmcia_request_io(p_dev, &p_dev->io) != 0)
+#endif
 			goto next_entry;
 	}
 	return 0;
@@ -310,15 +341,23 @@ spectrum_cs_config(struct pcmcia_device
 		goto failed;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	ret = pcmcia_request_irq(link, orinoco_interrupt);
+#else
+	ret = pcmcia_request_irq(link, &link->irq);
+#endif
 	if (ret)
 		goto failed;
 
 	/* We initialize the hermes structure before completing PCMCIA
 	 * configuration just in case the interrupt handler gets
 	 * called. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
 	mem = ioport_map(link->resource[0]->start,
 			resource_size(link->resource[0]));
+#else
+	mem = ioport_map(link->io.BasePort1, link->io.NumPorts1);
+#endif
 	if (!mem)
 		goto failed;
 
@@ -345,8 +384,16 @@ spectrum_cs_config(struct pcmcia_device
 	}
 
 	/* Register an interface with the stack */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	if (orinoco_if_add(priv, link->resource[0]->start,
 			   link->irq, NULL) != 0) {
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	if (orinoco_if_add(priv, link->io.BasePort1,
+			   link->irq, NULL) != 0) {
+#else
+	if (orinoco_if_add(priv, link->io.BasePort1,
+			   link->irq.AssignedIRQ, NULL) != 0) {
+#endif
 		printk(KERN_ERR PFX "orinoco_if_add() failed\n");
 		goto failed;
 	}
--- a/drivers/ssb/main.c
+++ b/drivers/ssb/main.c
@@ -490,7 +490,11 @@ static int ssb_devices_register(struct s
 			break;
 		case SSB_BUSTYPE_PCMCIA:
 #ifdef CONFIG_SSB_PCMCIAHOST
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 			sdev->irq = bus->host_pcmcia->irq;
+#else
+			sdev->irq = bus->host_pcmcia->irq.AssignedIRQ;
+#endif
 			dev->parent = &bus->host_pcmcia->dev;
 #endif
 			break;
